import math


def getprimes(n):
    ls = [i if i % 2 != 0 and i % 3 != 0 and i % 5 != 0 else 0 for i in range(n + 1)]
    ls[1], ls[2], ls[3], ls[5] = 0, 2, 3, 5
    for i in range(6, n + 1, 6):
        f = i - 1
        if f != 0:
            for j in range(2 * f, n + 1, f):
                ls[j] = 0
            continue
        f = i + 1
        if f != 0:
            for j in range(2 * f, n + 1, f):
                ls[j] = 0
    return filter(lambda x: x != 0, ls)


# 
# 
# # print(list(filter(lambda x: str(x)[-1] == '7' or str(x)[-1] == '1', getprimes(1000))))
# l = set(getprimes(10 ** 8))
# zs = 0
# mx = []
# with open('primes.txt') as f:
#     nums = list(map(int, f.read().strip().split()))
# for n in nums:
#     if n > 10 ** 8:
#         mx.append(n)
#         continue
#     if n in l:
#         zs += 1
# print(zs)
# print(mx)


import random


def runFermatPower(a, b, n):
    """
    计算(a**b)%n
    :param a: 底数
    :param b: 指数
    :param n: 取余
    :return: (a**b)%n
    """
    res = 1
    while b > 0:
        if (b & 1) == 1:
            res = (res * a) % n
        b >>= 1
        a = (a * a) % n
    return res


c = 506733
bigNum = [542693491967, 142787902577, 452440529173, 663634895869, 71242929179, 999870483413, 441673697183, 895134836909,
          59008094959, 812048153483, 153230177243, 5986461211, 825268545161, 85386152959, 305669636917, 176618331487,
          627185459239, 517233054923, 347714268719, 75380450897, 652349118967, 746710276723, 887316078643, 55623754253,
          726602124691, 63723051253, 11944000489, 14326008041, 995344474081, 127374806651, 101228446879, 782792370337,
          7616731547, 672817895497, 309261587441, 993510068537, 898280626321, 691250724803, 436362423451, 135244424501,
          873959450791, 404517752423, 803431472291, 890481756773, 299729772337, 993254812121, 939705423281,
          928689411767, 950796808643, 925182899009, 867933942403, 177084914339, 374154056921, 195931411013,
          636268614181, 845966263637, 669349089677, 279219681547, 116772294307, 458677064359, 414099720659,
          553029935971, 225122592047, 523383194647, 291752440213, 29190046721, 756126896941, 400963923179, 807339716593,
          666619632839, 792597812483, 157223341237, 515677221383, 869902952023, 277744493561, 279840195947, 12066121523,
          659914745389, 796743912131, 973038777059, 856703807231, 66169702601, 987064845247, 916671221021, 884623305749,
          504935549881, 232438712231, 701919604183, 542037833447, 521942095081, 726449610001, 840499018589,
          492469281101, 757165962919, 437417377471, 903288533789, 254110134101, 265121359891, 776841707227,
          854559132599, 325401328397, 675731682791, 730947154187, 280786162939, 670729451441, 48996391291, 286681507897,
          847973529401, 166381727761, 568868879153, 56085663143, 417414542761, 666771906149, 857635614683, 188918440631,
          490214446741, 82741563491, 411523187461, 304024439243, 912661149107, 556591023551, 934801057481, 828742723319,
          814141769183, 528476615281, 560425065263, 224638484077, 610321268093, 655599334577, 624348698849]
for p in bigNum:
    K = 100
    k = 0
    while k < K:  # 这里用while是后续判定随机完成率是否是100%
        b = int(random.random() * (p - 1) + 1)  # 生成一个1~p-1之间的随机整数
        factor = math.gcd(b, p)  # 计算b,p的最大公约数
        r = runFermatPower(b, p, p)  # 计算b^p mod p
        print(f"第{k + 1}次取随机数, 随机数b={b}, {b}和{p}的最大公约数为{factor}, r=({b}^{p})mod p={r}", end=', ')
        if factor > 1:
            print(f"因b={b}与p={p}的最大公约数为{factor}，不为互质数，故p={p}为合数")
            break
        elif r != b:
            print(f"因r={r},({b}^{p}) mod p ={r}!={b}, 故p={p}为合数")
            break
        else:
            print(f"故p={p}可能为素数")
            k += 1
    if k == K:
        print(f"经过{K}次循环验证, p={p}可能为素数, n为素数的概率为{(1 - 1 / (2 ** k)) * 100}%")
        c += 1
print(c)
